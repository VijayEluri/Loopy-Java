{"ts":1341005578380,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"package temp;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Observable;\nimport java.util.Observer;\nimport java.util.concurrent.Callable;\n\n/**\n The \"new To\" loop provides a looping alternative that is often slightly more\n concise than the for loop.  It allows you to replace\n<pre>\n    for (Object x : new Integer[] {8,6,7,5,3,0,9}) { print(\"Jenny:\" + x); };\n</pre>\n * with \n<pre>\n    new To(8,6,7,5,3,0,9) {{ print(\"Jenny:\" + x); }};\n</pre>\n<p>\nUnlike, the standard for loop, the new To loop also accepts IteratorS and EnumerationS\n<pre>\n    new To(System.getProperties().keys()) {{ print(x); }};\n</pre>\nA To is an object that implements several interfaces, so that adapters aren't\nrequired in order use it in a variety of ways.  Because it is a Collection,\nit can be executed again later, along with additional code, using a for loop.\n<pre>\n    for (Object x : to) {\n        // do additional stuff to x, here\n    }\n</pre>\nIf no additional action is to be taken on the subsequent runs, it can simply\nbe run as a Runnable, or called as a Callable.  No matter how the loop is executed\nagain, any registered ObserverS are notified.  Thus, in addition to being nested\nlike for loops, To loops can be wired together for interleaved execution.\n\n<pre>\n    To tick = new To(1,2,3) {{ print(\"tick:\" + x); }};\n    To tock = new To(4,5,6) {{ print(\"tock:\" + x); }};\n\n    tick.addObserver(tock);\n\n    tick.run();\n</pre>\n *\n * <p>\n Unfortunately, despite these advantages, the current implementation\n has several glaring limitations.\n * <ul>\n * <li> Special care must be taken to handle empty loops\n * <li> Only supports To loops that are static classes\n * <li> It has much more overhead and is much slower than an equivalent for loop\n * </ul>\n * \n */\npublic class To<X>\n    extends Observable\n    implements Iterator<X>, Collection<X>, Enumeration<X>, Runnable, Callable, Observer\n{\n\n    /**\n     * The iterator we defer to\n     */\n    private Iterator<X> iterator;\n\n    /**\n     * The loop variable value\n     */\n    public final X x;\n\n    /**\n     * The arguments for this To\n     */\n    private final List<X> args = new ArrayList();\n\n    /**\n     * The constructor for the (generally anonymous) class that extends this one.\n     */\n    private final Constructor<?> extending;\n\n    /**\n     * The formal parameters of the extending constructor.\n     */\n    private final Class[] formals;\n\n    /**\n     * The type of argument that was passed in the constructor\n     */\n    private final Type type;\n\n    /**\n     * The types of arguments that can be passed in the constructor.\n     */\n    private enum Type { VARARG, ITERATOR, ITERABLE, ENUMERATION; }\n    /**\n     * This wraps an arg, so that it can be passed through the constructor.\n     */\n    private static final class ArgWrapper implements Iterator, Iterable, Enumeration {\n        /**\n         * The single value we hold.\n         */\n        final Object x;\n        final Constructor<?> extending;\n        final Class[] formals;\n\n        ArgWrapper(Object x, Constructor<?> extending, Class[] formals) {\n            this.x = x;\n            this.extending = extending;\n            this.formals = formals;\n        }\n\n        public Iterator       iterator() { return this; }\n        public boolean hasMoreElements() { return true; }\n        public Object      nextElement() { return x; }\n        public boolean         hasNext() { return true; }\n        public Object             next() { return x; }\n        public void             remove() {}\n    } // ArgWrapper\n\n    /**\n     * Override this constructor for looping through individually specified values.\n     */\n    protected To(X... xs) {\n        type = Type.VARARG;\n        if (xs==null || xs.length==0) {\n            throw badArgs(xs);\n        }\n\n        // ArgWrapper\n        // This was created by the last if block in this constructor.\n        // Reflectively create a new normal instance.\n        if (xs[0] instanceof ArgWrapper) {\n            ArgWrapper wrapper = (ArgWrapper) xs[0];\n            x = (X) wrapper.x;\n            extending = wrapper.extending;\n            formals   = wrapper.formals;\n            return;\n        }\n        extending = extendingConstructor();\n        formals = extending.getParameterTypes();\n\n        // single value -- we can handle this\n        if (xs.length == 1) {\n            x = xs[0];\n            return;\n        }\n\n        // Multiple values\n        // This is the constructor our subclass will use.\n        if (xs.length > 1) {\n            for (int i=0; i<xs.length-1; i++) {\n                X arg = (X) xs[i];\n                args.add(arg);\n                newInstanceWithArg(arg);\n            }\n            x = xs[xs.length - 1];\n            args.add(x);\n            return;\n        }\n        throw badArgs(xs);\n    }\n\n    /**\n     * Override this constructor for looping through individually specified values.\n     */\n    protected To(Iterable<X> iterable) {\n        type = Type.ITERABLE;\n        if (iterable==null) {\n            throw badArgs();\n        }\n        extending = extendingConstructor();\n        formals = extending.getParameterTypes();\n        // ArgWrapper\n        // This was created by the last if block in this constructor.\n        // Reflectively create a new normal instance.\n        if (iterable instanceof ArgWrapper) {\n            ArgWrapper wrapper = (ArgWrapper) iterable;\n            x = (X) wrapper.x;\n            return;\n        }\n\n        // must not be empty\n        Iterator i = iterable.iterator();\n        if (!i.hasNext()) {\n            throw badArgs();\n        }\n\n        X arg = (X) i.next();\n        // single value -- we can handle this\n        if (!i.hasNext()) {\n            x =  arg;\n            args.add(arg);\n            return;\n        }\n\n        // Multiple values\n        // This is the constructor our subclass will use.\n        for (; i.hasNext(); arg = (X) i.next()) {\n            args.add(arg);\n            if (i.hasNext()) {\n                newInstanceWithArg(arg);\n            }\n        }\n        args.add(arg);\n        x = arg;\n    }\n\n    /**\n     * Override this constructor for looping through individually specified values.\n     */\n    protected To(Iterator<X> i) {\n        type = Type.ITERATOR;\n        if (i==null) {\n            throw badArgs();\n        }\n        // ArgWrapper\n        // This was created by the last if block in this constructor.\n        // Reflectively create a new normal instance.\n        if (i instanceof ArgWrapper) {\n            ArgWrapper wrapper = (ArgWrapper) i;\n            x = (X) wrapper.x;\n            extending = wrapper.extending;\n            formals   = wrapper.formals;\n            return;\n        }\n        extending = extendingConstructor();\n        formals = extending.getParameterTypes();\n\n        // must not be empty\n        if (!i.hasNext()) {\n            throw badArgs();\n        }\n\n        X arg = i.next();\n        // single value -- we can handle this\n        if (!i.hasNext()) {\n            x = arg;\n            args.add(arg);\n            return;\n        }\n\n        // Multiple values\n        // This is the constructor our subclass will use.\n        for (; i.hasNext(); arg = i.next()) {\n            args.add(arg);\n            if (i.hasNext()) {\n                newInstanceWithArg(arg);\n            }\n        }\n        args.add(arg);\n        x = arg;\n    }\n\n    /**\n     * Override this constructor for looping through individually specified values.\n     */\n    protected To(Enumeration<X> e) {\n        type = Type.ENUMERATION;\n        if (e==null) {\n            throw badArgs();\n        }\n        // ArgWrapper\n        // This was created by the last if block in this constructor.\n        // Reflectively create a new normal instance.\n        if (e instanceof ArgWrapper) {\n            ArgWrapper wrapper = (ArgWrapper) e;\n            x = (X) wrapper.x;\n            extending = wrapper.extending;\n            formals   = wrapper.formals;\n            return;\n        }\n        extending = extendingConstructor();\n        formals = extending.getParameterTypes();\n\n        // must not be empty\n        if (!e.hasMoreElements()) {\n            throw badArgs();\n        }\n\n        X arg = e.nextElement();\n        // single value -- we can handle this\n        if (!e.hasMoreElements()) {\n            x = arg;\n            args.add(arg);\n            return;\n        }\n\n        // Multiple values\n        // This is the constructor our subclass will use.\n        for (; e.hasMoreElements(); arg = e.nextElement()) {\n            args.add(arg);\n            if (e.hasMoreElements()) {\n                newInstanceWithArg(arg);\n            }\n        }\n        args.add(arg);\n        x = arg;\n    }\n\n    private static IllegalArgumentException badArgs(Object... xs) {\n        return new IllegalArgumentException(\"\" + xs);\n    }\n\n    /**\n     * Use the same constructor that is invoking us, to create a new instance.\n     * We do this in order to run whatever code in the subclass instance\n     * initializer again.  It can refer to x, which will have the given value.\n     */\n    private void newInstanceWithArg(Object x) {\n        try {\n            newInstanceWithArgWrapper0(x);\n        } catch (IllegalArgumentException e) {\n            String message = x + \" not valid for constructor \" + extending + \" taking \"+ Arrays.asList(formals);\n            throw new IllegalArgumentException(message);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        } finally {\n            setChanged();\n            notifyObservers(x);\n        }\n    }\n\n    private To newInstance0(Object x)\n        throws ClassNotFoundException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {\n        Object[] params = new Object[formals.length];\n        params[0] = x;\n        return (To) extending.newInstance(params);\n    }\n\n    private To newInstanceWithArgWrapper0(Object x)\n        throws ClassNotFoundException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {\n        Object[] params = new Object[formals.length];\n        params[0] = new ArgWrapper(x,extending,formals);\n        if (extending.isVarArgs()) {\n            params = new Object[] {params};\n        }\n        return (To) extending.newInstance(params);\n    }\n\n    /**\n     * Return the constructor of the class that is extending this one.\n     */\n    private static Constructor<?> extendingConstructor() {\n        try {\n            return extendingConstructor0();\n        } catch (ClassNotFoundException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private static Constructor<?> extendingConstructor0() throws ClassNotFoundException {\n        Class<? extends To> c = (Class<To>) Class.forName(extendingClass());\n        Constructor<?> con = c.getDeclaredConstructors()[0];\n        return con;\n    }\n    /**\n     * Return the (usually anonymous) class that extends this one.\n     */\n    private static String extendingClass() {\n        for (StackTraceElement e : Thread.currentThread().getStackTrace()) {\n            String c = e.getClassName();\n            if (isExtendingClass(c)) {\n                return c;\n            }\n        }\n        throw new IllegalStateException();\n    }\n\n    private static boolean isExtendingClass(String c) {\n        return  c !=null &&\n              ! c.equals(To.class.getName()) &&\n              ! c.equals(Thread.class.getName());\n    }\n\n    /*\n     * The next set of methods are for Iteration and Enumeration.\n     */\n    public boolean hasMoreElements() { return hasNext(); }\n    public X           nextElement() { return next(); }\n    public boolean         hasNext() {\n        if (iterator==null) {\n            iterator();\n        }\n        return iterator.hasNext();\n    }\n    final public       void remove() { iterator.remove(); }\n    public X                  next() {\n        X x = (X) iterator.next();\n        newInstanceWithArg(x);\n        this.notifyObservers(x);\n        return x;\n    }\n\n    /**\n     * Run this To loop.\n     */\n    public void run() {\n        for (Object x : args) {\n            newInstanceWithArg(x);\n        }\n    }\n\n    /**\n     * Call this To loop;\n     */\n    public Object call() {\n        run();\n        return null;\n    }\n\n    /**\n     * Return an iterator that can be used to iterate through this loop.\n     */\n    public Iterator<X> iterator() {\n        iterator = args.iterator();\n        return this;\n    }\n\n    // the next several methods are from Collection\n    public int size() {\n        return args.size();\n    }\n\n    public boolean isEmpty() {\n        return args.isEmpty();\n    }\n\n    public boolean contains(Object o) {\n        return args.contains(o);\n    }\n\n    public Object[] toArray() {\n        return args.toArray();\n    }\n\n    public Object[] toArray(Object[] a) {\n        return args.toArray(a);\n    }\n\n    public boolean add(X e) {\n        boolean flag = args.add(e);\n        notifyObservers(e);\n        return flag;\n    }\n\n    public boolean remove(Object o) {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    public boolean containsAll(Collection c) {\n        return args.containsAll(c);\n    }\n\n    public boolean addAll(Collection<? extends X> c) {\n        boolean flag = args.addAll(c);\n        for (Object o : c) {\n            notifyObservers(o);\n        }\n        return flag;\n    }\n\n    public boolean removeAll(Collection c) {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    public boolean retainAll(Collection c) {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    public void clear() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    public void update(Observable o, Object arg) {\n        if (!hasNext()) {\n            iterator();\n        }\n        next();\n    }\n\n    /**\n     * @param args the command line arguments\n     * @throws Exception\n     */\n    public static void main(String[] args) throws Exception {\n        List list1 = new ArrayList();\n        list1.add(1);\n\n        To iterable1 = new To(list1)                             {{print(\"iterable:\" +x); }};\n        To iterator1 = new To(list1.iterator())                  {{print(\"iterator:\" +x); }};\n        To enumeration1 = new To(Collections.enumeration(list1)) {{print(\"enumeration:\" +x); }};\n\n        List list2 = new ArrayList();\n        list2.add(1);\n        list2.add(2);\n\n        To iterable2 = new To(list2)                             {{print(\"iterable:\" +x); }};\n        To iterator2 = new To(list2.iterator())                  {{print(\"iterator:\" +x); }};\n        To enumeration2 = new To(Collections.enumeration(list2)) {{print(\"enumeration:\" +x); }};\n\n        new To(\"bar\",\"baz\") {{ print(\"2:\" +x);  }};\n        new To(1,2,3)       {{ print(\"3:\" +x);  }};\n        new To(1,2,3,4)     {{ print(\"4:\" + x); }};\n        new To(8,6,7,5,3,0,9)   {{ print(\"Jenny:\" + x); }};\n        for (Object x : Arrays.asList(new Integer[] {8,6,7,5,3,0,9})) { print(\"Jenny:\" + x); };\n\n        new To(System.getProperties().keys()) {{ print(x); }};\n\n        for (Object o :new To(1,2){}) {}\n\n        new To(iterable1,iterator1,enumeration1) {{\n           ((To)x).run();\n        }};\n        new To(iterable2,iterator2,enumeration2) {{\n           ((To)x).run();\n        }};\n\n        To<To> to = new To(iterable2,iterator2,enumeration2) {{\n           ((To)x).run();\n        }};\n\n        for (To x : to) {\n            for (Object y : x) {\n                print(\"In for \" + y);\n            }\n        }\n\n        To tick = new To(1,2,3) {{ print(\"tick:\" + x); }};\n        To tock = new To(4,5,6) {{ print(\"tock:\" + x); }};\n\n        tick.addObserver(tock);\n\n        print(\"Convoluted\");\n\n        tick.run();\n\n        print(\"Done\");\n        System.exit(0);\n    }\n\n    static void print(Object x) {\n        System.out.println( x );\n    }\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":16117}]],"length":16117}
